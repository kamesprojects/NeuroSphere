/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: mikeramos (https://sketchfab.com/mikeramos)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/360-sphere-robot-a0bd28b7133648848427a5c27975611b
Title: 360 Sphere Robot
*/

import { useCallback, useEffect, useRef } from 'react';
import { useGLTF } from '@react-three/drei';
import { useThree, useFrame } from '@react-three/fiber';
import { a } from '@react-spring/three';

import robotGuide from '../assets/3d/360_sphere_robot.glb';

export default function SphereGuide({ isRotating, setIsRotating, setCurrentStage, setScale, scaleLimits, ...props }) {
  const robotRef = useRef();

  const { gl, viewport } = useThree();
  const { nodes, materials } = useGLTF(robotGuide);

  const lastX = useRef(0);  
  const rotationSpeed = useRef(0); 
  const dampingFactor = 0.95;
  const activePointers = useRef(new Map());
  const pinchStartDistance = useRef(null);
  const pinchStartScale = useRef(null);
  const scaleRef = useRef(props.scale);

  useEffect(() => {
    scaleRef.current = props.scale;
  }, [props.scale]);
  
  const geom = (key) => (nodes && nodes[key] && nodes[key].geometry) ? nodes[key].geometry : undefined;

  const getPointerDistance = useCallback(() => {
    const pointers = Array.from(activePointers.current.values());
    if (pointers.length < 2) return 0;

    const [first, second] = pointers;
    const dx = first.x - second.x;
    const dy = first.y - second.y;
    return Math.hypot(dx, dy);
  }, []);

  const clampScale = useCallback(
    (candidate) => {
      if (!scaleLimits) return candidate;

      return candidate.map((value, index) => {
        const min = scaleLimits.min?.[index] ?? value;
        const max = scaleLimits.max?.[index] ?? value;
        return Math.min(max, Math.max(min, value));
      });
    },
    [scaleLimits]
  );

  const handlePointerDown = useCallback(
    (e) => {
      e.stopPropagation();
      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      activePointers.current.set(e.pointerId, { x: clientX, y: clientY });

      if (activePointers.current.size >= 2) {
        setIsRotating(false);
        rotationSpeed.current = 0;
        pinchStartDistance.current = getPointerDistance();
        pinchStartScale.current = scaleRef.current ? [...scaleRef.current] : null;
      } else {
        setIsRotating(true);
        rotationSpeed.current = 0;
        lastX.current = clientX;
      }

      if (e.target.setPointerCapture) {
        e.target.setPointerCapture(e.pointerId);
      }
    },
    [getPointerDistance, setIsRotating]
  );

  const handlePointerUp = useCallback(
    (e) => {
      e.stopPropagation();
      e.preventDefault();

      activePointers.current.delete(e.pointerId);

      if (activePointers.current.size < 2) {
        pinchStartDistance.current = null;
        pinchStartScale.current = null;
      }

      if (activePointers.current.size === 0) {
        setIsRotating(false);
      }

      if (e.target.releasePointerCapture) {
        e.target.releasePointerCapture(e.pointerId);
      }
    },
    [setIsRotating]
  );

  const handlePointerMove = useCallback(
    (e) => {
      if (!robotRef.current) return;

      e.stopPropagation();
      e.preventDefault();

      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;

      if (activePointers.current.has(e.pointerId)) {
        activePointers.current.set(e.pointerId, { x: clientX, y: clientY });
      }

      if (activePointers.current.size >= 2 && setScale) {
        const distance = getPointerDistance();

        if (!pinchStartDistance.current || !pinchStartScale.current) {
          pinchStartDistance.current = distance;
          pinchStartScale.current = scaleRef.current ? [...scaleRef.current] : null;
          return;
        }

        if (pinchStartDistance.current === 0) return;

        const ratio = distance / pinchStartDistance.current;
        const baseScale = pinchStartScale.current;
        if (!baseScale) return;

        const nextScale = baseScale.map((value) => value * ratio);
        const clampedScale = clampScale(nextScale);
        rotationSpeed.current = 0;
        scaleRef.current = clampedScale;
        setScale(() => clampedScale);
        return;
      }

      if (!isRotating) return;

      const delta = (clientX - lastX.current) / viewport.width;
      const step = delta * 0.01 * Math.PI;

      robotRef.current.rotation.y += step;
      lastX.current = clientX;
      rotationSpeed.current = step;
    },
    [clampScale, getPointerDistance, isRotating, setScale, viewport.width]
  );

  const handleWheel = useCallback(
    (e) => {
      if (!setScale || !scaleRef.current) return;

      e.stopPropagation();
      e.preventDefault();

      const magnitude = Math.min(Math.abs(e.deltaY) / 300, 0.25);
      const factor = e.deltaY > 0 ? 1 - magnitude : 1 + magnitude;

      if (factor === 1) return;

      const nextScale = scaleRef.current.map((value) => value * factor);
      const clampedScale = clampScale(nextScale);
      rotationSpeed.current = 0;
      scaleRef.current = clampedScale;
      setScale(() => clampedScale);
    },
    [clampScale, setScale]
  );

  useFrame(() => {
    if (!robotRef.current) return;

    if(!isRotating) {
      rotationSpeed.current *= dampingFactor;
      if (Math.abs(rotationSpeed.current) < 0.00001) {
        rotationSpeed.current = 0;
      }

      robotRef.current.rotation.y += rotationSpeed.current;
    } else {
      const rotation = robotRef.current.rotation.y;

      const normalizeRotation = ((rotation % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);

      // Set the current stage based on the robot's orientation
      switch(true) {
        case normalizeRotation >= 5.45 && normalizeRotation <= 5.85:
          setCurrentStage(4);
          break;
        case normalizeRotation >= 0.85 && normalizeRotation <= 1.3:
          setCurrentStage(3);
          break;
        case normalizeRotation >= 2.4 && normalizeRotation <= 2.6:
          setCurrentStage(2);
          break;
        case normalizeRotation >= 4.25 && normalizeRotation <= 4.75:
          setCurrentStage(1);
          break;
        default:
          setCurrentStage(null);
      }
    }
  });

  const handleArrowkey = useCallback((e) => {
    if (!robotRef.current) return;

    if(e.key === 'ArrowLeft') {
      robotRef.current.rotation.y += 0.1 * Math.PI;
      rotationSpeed.current = 0.1 * Math.PI;
    }
    if(e.key === 'ArrowRight') {
      robotRef.current.rotation.y -= 0.1 * Math.PI;
      rotationSpeed.current = -0.1 * Math.PI;
    }
    if(e.key === 'ArrowUp' || e.key === 'ArrowDown') {
      setIsRotating(false);
    }
  }, [setIsRotating]);

  useEffect(() => {
    const canvas = gl.domElement;
    canvas.style.touchAction = 'none';

    canvas.addEventListener('pointerdown', handlePointerDown, { passive: false });
    canvas.addEventListener('pointerup', handlePointerUp, { passive: false });
    canvas.addEventListener('pointermove', handlePointerMove, { passive: false });
    canvas.addEventListener('pointercancel', handlePointerUp, { passive: false });
    canvas.addEventListener('wheel', handleWheel, { passive: false });
    document.addEventListener('keydown', handleArrowkey);
    document.addEventListener('keyup', handleArrowkey);
    
    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown);
      canvas.removeEventListener('pointerup', handlePointerUp);
      canvas.removeEventListener('pointermove', handlePointerMove);
       canvas.removeEventListener('pointercancel', handlePointerUp);
       canvas.removeEventListener('wheel', handleWheel);
      document.removeEventListener('keydown', handleArrowkey);
      document.removeEventListener('keyup', handleArrowkey);
    };
  }, [gl, handleArrowkey, handlePointerDown, handlePointerMove, handlePointerUp, handleWheel]);

  return (
    <a.group ref={robotRef} {...props}>
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]} scale={0.017}>
          <group name="8cfcbf279e5145b29fef01b31cc1d658fbx" rotation={[Math.PI / 2, 0, 0]}>
            <group name="Object_2">
              <group name="RootNode">
                <group name="sphere_body" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
                  <mesh
                    name="sphere_body_glossy_paint_white_0"
                    geometry={geom('sphere_body_glossy_paint_white_0')}
                    material={materials.glossy_paint_white}
                  />
                  <mesh
                    name="sphere_body_black_matte_0"
                    geometry={geom('sphere_body_black_matte_0')}
                    material={materials.black_matte}
                  />
                  <mesh
                    name="sphere_body_metal_0"
                    geometry={geom('sphere_body_metal_0')}
                    material={materials.metal}
                  />
                  <mesh
                    name="sphere_body_eyes_light_0"
                    geometry={geom('sphere_body_eyes_light_0')}
                    material={materials.eyes_light}
                  />
                  <mesh
                    name="sphere_body_dark_glass_0"
                    geometry={geom('sphere_body_dark_glass_0')}
                    material={materials.dark_glass}
                  />
                  <mesh
                    name="sphere_body_black_matter_blender_0"
                    geometry={geom('sphere_body_black_matter_blender_0')}
                    material={materials.black_matter_blender}
                  />
                  <mesh
                    name="sphere_body_thruster_light_0"
                    geometry={geom('sphere_body_thruster_light_0')}
                    material={materials.thruster_light}
                  />
                  <mesh
                    name="sphere_body_blender_glass_0"
                    geometry={geom('sphere_body_blender_glass_0')}
                    material={materials.blender_glass}
                  />
                </group>
              </group>
            </group>
          </group>
        </group>
      </group>
    </a.group>
  )
}